<!DOCTYPE html>
<html>
<head>
<title>Decomposing Software</title>
<!-- 2015-05-13 Wed 17:31 -->
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="Benoit Fleury &lt;me@benfle.com&gt;">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
</head>
<body>
<div id="content">
<h1 class="title">Decomposing Software</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a></li>
<li><a href="#sec-2">2. Why?</a>
<ul>
<li><a href="#sec-2-1">2.1. Why do we decompose software?</a></li>
<li><a href="#sec-2-2">2.2. Who is Christopher Alexander</a></li>
<li><a href="#sec-2-3">2.3. Notes on the Synthesis of Form</a></li>
<li><a href="#sec-2-4">2.4. Summary</a></li>
</ul>
</li>
<li><a href="#sec-3">3. How?</a>
<ul>
<li><a href="#sec-3-1">3.1. Information Hiding (Parnas)</a></li>
<li><a href="#sec-3-2">3.2. Beyond Information Hiding</a></li>
<li><a href="#sec-3-3">3.3. Conclusion</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Presentation
<ul class="org-ul">
<li>I am a Clojure contractor. I'm currently contracting with Cognitect.
</li>
<li>Thanks to softwareforgood for hosting us.
</li>
<li>And thanks to you for being here.
</li>
</ul>
</li>
<li>We're going to talk today about software decomposition.
</li>
<li>The talk is in 2 parts.
<ul class="org-ul">
<li>First, we're going to see why we decompose software? This part will be based on Christopher Alexander's book Notes on The Synthesis of Form. I think understanding why we decompose software will shed light on how to do it.
</li>
<li>The second part will look at how to decompose software. We're going to look at a series of decompositions inspired by David Parnas' Paper On The Criteria To BE Used in Decomposing Systems into Modules. But this paper has been written in 1972 and some progresses have been made since then regarding software decomposition. So we're going to extend the example in this paper to illustrate interesting ways to decompose software.
</li>
</ul>
</li>
<li>Why is it important?
<ul class="org-ul">
<li>Because it's a critical tool to manage complexity in software.
</li>
<li>It always apply, whatever hardware/software stack you're using.
</li>
<li>Because it has a direct impact on the quality of the software. (Shown in part I.)
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Why?</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Why do we decompose software?</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>A few reasons
<ul class="org-ul">
<li>Because decomposition is good.
</li>
<li>Shortens development time because separate groups can work on different modules.
</li>
<li>To simplify the problem (Divide &amp; Conquer)
</li>
<li>To make the system more easily understandable.
</li>
<li>To make the system more flexible, make it easier to change individual parts of the system.
</li>
</ul>
</li>
<li>I think that of all these reasons one is fundamental and will help us understand how we can decompose software: product flexibility.
</li>
<li>To understand what flexibility really means and why it is fundamental to the software process, to any design process actually, we can look at Christopher Alexander's Notes on the Synthesis of Form.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Who is Christopher Alexander</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>Architect
</li>
<li>Many books written during the last 50 years. Same underlying idea.
</li>
<li>Design Patterns and Agile software development comes from him. So it's important to know about him.
</li>
<li>Continuity of his work from NoSoF to Nature of order
<ul class="org-ul">
<li>No need to be familiar with his work, we start at the beginning: NoSoF
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Notes on the Synthesis of Form</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>Design problem?
<ul class="org-ul">
<li>Definition of design problems: meet set of requirements but some of them are in conflict.
</li>
<li>Today's design problems are beyong the capabilities of individual designers.
<ul class="org-ul">
<li>Too much information
</li>
<li>Complex problems
</li>
<li>Change frequently
</li>
</ul>
</li>
</ul>
</li>
<li>How can we simplify design problems?
<ul class="org-ul">
<li>Refuse responsibility -&gt; all based on intuition, artist
</li>
<li>"when a designer does not understand a problem clearly enough to find the order it really calls for, he falls back on some arbitrarily chosen formal order."
</li>
<li>styles: copy of past forms
</li>
<li>functional decomposition: what the book is about
</li>
</ul>
</li>
<li>Let's go back to the definition of a design problem.
<ul class="org-ul">
<li>Usually we understand a design problem as a list of requirements.
<ul class="org-ul">
<li>The software must do this, and this, and this. It should not cost too much&#x2026;
</li>
</ul>
</li>
<li>Alexander is saying that:
<ul class="org-ul">
<li>both the form and the context should be the subject of the design process
</li>
<li>we cannot list all the requirements
<ul class="org-ul">
<li>too large
</li>
<li>but also limited to the categories we know and what we can measure.
</li>
</ul>
</li>
<li>the only way to do it is by detecting misfit.
<ul class="org-ul">
<li>This is a little asbtract but I think there is a parallel in software with testing. We never know if our software works perfectly, the best we can do is to write software that passes a set of tests. The goal of the tests is to detect these misfits. But tests are not enough. There are fundamental aspects of software that cannot be tested.
</li>
</ul>
</li>
<li>These misfits are the forces from the context which much shape the form.
</li>
<li>"What does make design a problem in real world cases is that we are trying to make a diagram for forces whose field we do not understand."
<ul class="org-ul">
<li>If we were able to list all the requirements for the form it wouldn't be a design problem.
</li>
<li>The best we can do is to list the most important and likely to occur misfits.
</li>
</ul>
</li>
</ul>
</li>
<li>Changing our view of the software design process:
<ul class="org-ul">
<li>From: list of requirements -&gt; product, done
</li>
<li>To: create order between for mand context while the context is constantly changing.
<ul class="org-ul">
<li>the form, the software (hardware) is the part of the environment we have control on.
</li>
<li>software is never done: adaptive process.
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>The design process
<ul class="org-ul">
<li>We've seen that we can't do better than creating order by detecting misfits.
</li>
<li>So the quality of our software will depend on how its process reacts to these misfits.
<ul class="org-ul">
<li>First, the process should make it easy to fix the misfits when detected.
<ul class="org-ul">
<li>this happens at all scale: from your REPL to the bug reported by a user in production.
</li>
</ul>
</li>
<li>But this is not enough, the fix of the misfit should be isolated to not generate misfits in other parts of the system.
<ul class="org-ul">
<li>if each bug fix generates 2 new bugs, you're in trouble.
</li>
</ul>
</li>
</ul>
</li>
<li>The book then present a formal method for architects to identify the subsets of interacting forces. As Alexander explains in the preface, it is not the important aspect of the book and it doesn't concern us much for software since we don't have the physical constraints architects have.
</li>
<li>In software we create the relationships between our misfits. What is important to remember is that our subsystems, or modules, should be loosely coupled.
</li>
<li>I think we have now all the concepts we need to understand Parnas' paper.
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Summary</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>we make good form by creating order between form and context
</li>
<li>order is created by detecting misfits and removing them
</li>
<li>the quality of the software will depend on how the process helps this detection and fix of the misfits.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> How?</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Information Hiding (Parnas)</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>KWIC system
</li>
<li>Modularization 1: flow chart (arbitrary formal order)
<ul class="org-ul">
<li>what happens when we think of modularization simply as divide and conquer.
</li>
</ul>
</li>
<li>Modularization 2: information hiding
<ul class="org-ul">
<li>we isolate each design changes (potential misfits)
</li>
</ul>
</li>
<li>Comparison
<ul class="org-ul">
<li>table with impact of each design change on subsystems.
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Beyond Information Hiding</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>LISP cons cell
<ul class="org-ul">
<li>Don't just look down, look up.
</li>
<li>Software parts of a larger whole.
</li>
<li>Can reuse existing libraries.
</li>
</ul>
</li>
<li>Seq abstraction
</li>
<li>Transducers
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Conclusion</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>Also applies to large systems (microservices: <a href="http://martinfowler.com/articles/microservices.html">http://martinfowler.com/articles/microservices.html</a>)
<ul class="org-ul">
<li>Actually apply to any man-made form.
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Benoit Fleury &lt;me@benfle.com&gt;</p>
<p class="date">Created: 2015-05-13 Wed 17:31</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
